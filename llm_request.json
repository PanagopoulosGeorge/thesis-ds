{
  "prompt": "highSpeedNearCoast",
  "temperature": null,
  "max_tokens": null,
  "model": null,
  "system_prompt": "You are an assistant in constructing rules in the language of the Run-Time Event Calculus (RTEC),\ngiven a composite activity description in natural language. The Event Calculus is a logic-based\nformalism for representing and reasoning about events and their effects. The Run-Time Event\nCalculus (RTEC) is a Prolog programming implementation of the Event Calculus,\nthat has been optimised for composite activity recognition.\n\nFollowing the Prolog convention, variables start with an upper-case letter, while predicates and\nconstants start with a lower-case letter. Each rule ends with a full-stop \".\", while the head of a\nrule is separated from its body with \":-\".\n\nA fluent is a property that may have different values at different points in time. The term F=V\ndenotes that fluent F has value V. Boolean fluents are a special case in which the possible values\nare \"true\" and \"false\".\n\nBelow are the predicates of RTEC.\n\nRTEC - Predicate 1: happensAt(E,T)\nMeaning: Event E occurs at time T\n\nRTEC - Predicate 2: holdsAt(F=V,T)\nMeaning: The value of fluent F is V at time T\n\nRTEC - Predicate 3: holdsFor(F=V,I)\nMeaning: I is the list of the maximal intervals during which F=V holds continuously\n\nRTEC - Predicate 4: initiatedAt(F=V,T)\nMeaning: At time T a period of time for which F=V is initiated\n\nRTEC - Predicate 5: terminatedAt(F=V,T)\nMeaning: At time T a period of time for which F=V is terminated\n\nRTEC - Predicate 6: union_all(L,I)\nMeaning: I is the list of maximal intervals produced by the union of the lists of maximal intervals of list L\n\nRTEC - Predicate 7: intersect_all(L,I)\nMeaning: I is the list of maximal intervals produced by the intersection of the lists of maximal intervals of list L\n\nRTEC - Predicate 8: relative_complement_all(I',L,I)\nMeaning: I is the list of maximal intervals produced by the relative complement of the list of maximal intervals I'\nwith respect to every list of maximal intervals of list L\n\nRTEC also includes two built-in events.\n\nBuilt-in event 1: start(F=V)\nMeaning: Event \"start(F=V)\" takes place at each starting point of each maximal interval of fluent-value pair F=V\n\nBuilt-in event 2: end(F=V)\nMeaning: Event \"end(F=V)\" takes place at each ending point of each maximal interval of fluent-value pair F=V\n\nThere are two ways in which a composite activity may be defined in the language of RTEC.\n\nIn the first case, a composite activity definition may be specified by means of rules with\n\"initiatedAt(F=V, T)\" or \"terminatedAt(F=V, T)\" in their head. This is called a simple fluent definition.\n\nThe first body literal of an \"initiatedAt(F=V,T)\" rule is a positive \"happensAt\" predicate;\nthis predicate is followed by a possibly empty set of positive or negative \"happensAt\" and \"holdsAt\"\npredicates. Negative predicates are prefixed with \"not\" which expresses negation-by-failure.\nIn some cases, the body of an \"initiatedAt(F=V,T)\" rule may include predicates expressing background knowledge.\n\"terminatedAt(F=V,T)\" rules are specified in a similar way.\n\nThe second way in which a composite activity may be defined in the language of RTEC concerns statically\ndetermined fluents. In this case, a composite activity definition may be specified by means of a rule\nwith \"holdsFor(F=V, I)\" in its head.\n\nThe body of such a rule may include \"holdsFor\" conditions for fluents other than F, as well as some of the\ninterval manipulation constructs of RTEC, i.e. \"union_all\", \"intersect_all\", and \"relative_complement_all\".\nIn some cases, a \"holdsFor(F=V, I)\" rule may include predicates expressing background knowledge.\nA rule with \"holdsFor(F=V, I)\" in the head is called a statically determined fluent definition.\n\n\nNow, we will start with the generation of the composite activity definitions for maritime situational awareness (MSA). \nFirst, we will present the events and input fluents. \nSecond, we will present the predicates expressing the background knowledge. \nThird, we will provide the composite activity definitions in natural language and ask for their specification in the language of RTEC.\n\n\n\nIn addition to the built-in events of RTEC, you may use the following MSA events:\n\nMSA - Event 1: change_in_speed_start(Vessel)\nMeaning: “Vessel” started changing its speed.\n\nMSA - Event 2: change_in_speed_end(Vessel)\nMeaning: “Vessel” stopped changing its speed.\n\nMSA - Event 3: change_in_heading(Vessel)\nMeaning: “Vessel” changed its heading.\n\nMSA - Event 4: stop_start(Vessel)\nMeaning: “Vessel” started being idle.\n\nMSA - Event 5: stop_end(Vessel)\nMeaning: “Vessel” stopped being idle.\n\nMSA - Event 6: slow_motion_start(Vessel)\nMeaning: “Vessel” started moving at a low speed.\n\nMSA - Event 7: slow_motion_end(Vessel)\nMeaning: “Vessel” stopped moving at a low speed.\n\nMSA - Event 8: gap_start(Vessel)\nMeaning: “Vessel” stopped sending position signals.\n\nMSA - Event 9: gap_end(Vessel)\nMeaning: “Vessel” resumed sending position signals.\n\nMSA - Event 10: entersArea(Vessel,AreaID)\nMeaning: “Vessel” enters an area with id “AreaID”.\n\nMSA - Event 11: leavesArea(Vessel,AreaID)\nMeaning: “Vessel” leaves an area with id “AreaID”.\n\nMSA - Event 12: velocity(Vessel,Speed,CourseOverGround,TrueHeading)\nMeaning: “Vessel” is moving with velocity “Speed”, while it is moving in the direction indicated by angle “CourseOverGround”, \nand its bow is pointing in the direction indicated by angle “TrueHeading”.\n\nPrompt MSA-Fluents:\nYou may also use the following MSA input fluent:\n\nMSA - Input Fluent 1: proximity(Vessel1, Vessel2) = true\nMeaning: “Vessel1” and “Vessel2” are close to each other.\n\n\n\nYou may use a MSA background knowledge predicate named “thresholds” with two arguments. \nThe first argument refers to the threshold type and the second one to the threshold value. \nThreshold values can be used to perform mathematical operations and comparisons.\n\nMSA Background Knowledge - Predicate 1: thresholds(hcNearCoastMax,HcNearCoastMax)\nMeaning: The maximum sailing speed that is safe for a vessel to have in a coastal area.\n\nMSA Background Knowledge - Predicate 2: thresholds(adriftAngThr,AdriftAngThr)\nMeaning: The maximum angle difference between the actual direction of a vessel and the direction of its bow for which we consider that the vessel is not drifting.\n\nMSA Background Knowledge - Predicate 3: thresholds(aOrMTime,AOrMTime)\nMeaning: The maximum temporal extent during which a vessel may be idle without being considered anchored or moored.\n\nMSA Background Knowledge - Predicate 4: thresholds(trawlspeedMin,TrawlspeedMin)\nMeaning: The minimum speed of a vessel engaged in a trawling activity.\n\nMSA Background Knowledge - Predicate 5: thresholds(trawlspeedMax,TrawlspeedMax)\nMeaning: The maximum speed of a vessel engaged in a trawling activity.\n\nMSA Background Knowledge - Predicate 6: thresholds(tuggingMin,TuggingMin)\nMeaning: The minimum speed of a vessel engaged in a tugging operation.\n\nMSA Background Knowledge - Predicate 7: thresholds(tuggingMax,TuggingMax)\nMeaning: The maximum speed of a vessel engaged in a tugging operation.\n\nMSA Background Knowledge - Predicate 8: thresholds(tuggingTime,TuggingTime)\nMeaning: The minimum duration of a tugging operation.\n\nMSA Background Knowledge - Predicate 9: thresholds(movingMin,MovingMin)\nMeaning: The minimum speed of a moving vessel.\n\nMSA Background Knowledge - Predicate 10: thresholds(movingMax,MovingMax)\nMeaning: The maximum speed of a moving vessel.\n\nMSA Background Knowledge - Predicate 11: thresholds(sarMinSpeed,SarMinSpeed)\nMeaning: The minimum speed of a vessel engaged in a search-and-rescue (SAR) operation.\n\nMSA Background Knowledge - Predicate 12: thresholds(trawlingTime,TrawlingTime)\nMeaning: The minimum duration of a trawling activity.\n\nMSA Background Knowledge - Predicate 13: thresholds(loiteringTime,LoiteringTime)\nMeaning: The minimum duration of a loitering activity.\n\nMSA Background Knowledge - Predicate 14: typeSpeed(Type,Min,Max,Avg)\nMeaning: The minimum, maximum, and average speed of each vessel type.\n\nMSA Background Knowledge - Predicate 15: vesselType(Vessel,Type)\nMeaning: The vessel type of each vessel.\n",
  "domain_prompt": null,
  "feedback": null,
  "fewshots": [
    {
      "user": "Given a composite maritime activity description, provide the rules in the language of RTEC.\n                 Composite Maritime Activity Description: “withinArea”. \n                 This activity starts when a vessel enters an area of interest. \n                 The activity ends when the vessel leaves the area that it had entered, \n                 or when the vessel stops transmitting its position, \n                 since we can no longer assume that the vessel remains in the same area \n                 in the case of transmission gaps.",
      "assistant": "The activity “withinArea” is expressed as a Boolean simple fluent with two arguments, i.e., “Vessel” and “AreaType”. \n This activity starts when a vessel enters an area of interest. \n We use an \"initiatedAt\" rule to express this initiation condition. \n The body literals of this rules are an event labelled “entersArea” with two arguments, “Vessel” and “Area”, \n and a background knowledge predicate named “areaType” with two arguments, \n “Area” and “AreaType”. This rule in the language of RTEC is the following:\n    ```prolog\n    initatedAt(withinArea(Vessel, AreaType)=true, T) :-\n        happensAt(entersArea(Vessel, Area), T),\n        areaType(Area, AreaType).\n    ```\nThe activity “withinArea” ends when a vessel leaves the area that it had entered. \nWe use a “terminatedAt” rule to describe this termination condition. \nThis rule includes an event named “leavesArea” with two arguments, i.e. “Vessel” and “Area”, \nand the background knowledge predicate “areaType”. This rule in the language of RTEC language is:\n    ```prolog\n    terminatedAt(withinArea(Vessel, AreaType)=true, T) :-\n        happensAt(leavesArea(Vessel, Area), T),\n        areaType(Area, AreaType).\n    ```\n\nIn addition to the aforementioned conditions, the activity “withinArea” ends when the vessel \nstops transmitting its position, i.e. when a communication gap starts. \nWe use a “terminatedAt” rule to express this termination condition. \nIn this rule, the second argument of the “withinArea” fluent is a ‘free’ Prolog variable, \ni.e. a variable starting with ‘_’. The body of this rule includes a single event \nnamed “gap_start” with one argument, i.e. “Vessel”. This rule in the language of RTEC is:\n    ```prolog\n    terminatedAt(withinArea(Vessel, _AreaType)=true, T) :-\n        happensAt(gap_start(Vessel), T).\n    ```"
    },
    {
      "user": "Given a composite maritime activity description, provide the rules in the language of RTEC.\nComposite Maritime Activity Description: “stopped”. \nThis activity starts when a vessel becomes idle near some port or far from all ports. \nThe activity ends when the vessel stops being idle, i.e., when it starts to move. \nWhen there is a gap in signal transmissions, we can no longer assume that the vessel remains stopped.",
      "assistant": "The activity “stopped” is expressed as a simple fluent. \nThis activity starts when a vessel becomes idle near some port. \nWe use an “initiatedAt” rule to describe this initiation condition. \nThe output is the fluent “stopped”, which has one argument, i.e. “Vessel”, and value “nearPorts”. \nThe “initiatedAt” rule includes an event named “stop_start” with one argument, i.e. “Vessel”. \nWe verify that the vessel is currently near some port by requiring that the fluent-value pair “withinArea(Vessel, nearPorts)=true” must hold. \nThis condition refers to the activity “withinArea”, which was learned in a previous example. \nThis rule in the language of RTEC is:\n    ```prolog\n    initiatedAt(stopped(Vessel)=nearPorts, T) :-\n        happensAt(stop_start(Vessel), T),\n        holdsAt(withinArea(Vessel, nearPorts)=true, T).\n    ```\nThe activity “stopped” may also start when a vessel becomes idle far from all ports. \nIn this case, the “stopped” fluent has value “farFromPorts”. \nWe use an “initiatedAt” rule to express this initiation condition. \nThe body of this rule includes an event named “stop_start” with one argument, i.e. “Vessel”. \nWe verify that the vessel is currently far from all ports by requiring that the fluent-value pair “withinArea(Vessel, nearPorts)=true” does not hold. \nThis rule in the language of RTEC is:\n    ```prolog\n    initiatedAt(stopped(Vessel)=farFromPorts, T) :-\n        happensAt(stop_start(Vessel), T),\n        not holdsAt(withinArea(Vessel, nearPorts)=true, T).\n    ```\n\nThe activity “stopped” ends when a vessel stops being idle, irrespective of the location of the vessel. \nWe use a “terminatedAt” rule to express this termination condition. \nMoreover, we use a free Prolog variable to express the value of the “stopped” fluent, called “_Status”, \ni.e. we place no constraints on the value of the “stopped” fluent. \nThe “terminatedAt” rule includes a single event named “stop_end” with one argument, i.e. “Vessel”. \nThis rule in the language of RTEC is:\n\n    ```prolog\n    terminatedAt(stopped(Vessel)=_Status, T) :-\n        happensAt(stop_end(Vessel), T).\n    ```\nThe activity “stopped” may also end when a communication gap starts. \nWe use a “terminatedAt” rule to express this termination condition. \nThis rule includes the built-in “start” event of RTEC, which expresses the start times of the maximal intervals of a given fluent-value pair. \nIn this case, the “start” event is applied to the gap fluent, expressing the times at which \na communication gap for the vessel in question starts. This rule in the language of RTEC is:\n    ```prolog\n    terminatedAt(stopped(Vessel)=_Status, T) :-\n        happensAt(start(gap(Vessel)=_GapStatus), T).\n    ```"
    },
    {
      "user": "Given a composite maritime activity description, provide the rules in the language of RTEC.\nComposite Maritime Activity Description: “underWay”. This activity lasts as long as a vessel is not stopped.",
      "assistant": "The activity “underWay” is expressed as a statically determined fluent. \nRules with “holdsFor” in the head specify the conditions in which a fluent holds. \nWe use a “holdsFor” rule to describe that the “underWay” activity lasts as long as a vessel is not stopped. \nThe output is Βoolean fluent named “underWay” with one argument, i.e. “Vessel”. \nWe specify “underWay” with the use of the fluent “movingSpeed”. \nWe express “underWay” as the disjunction of the three values of “movingSpeed”, \ni.e. “below”, “normal” and “above”. Disjunction in “holdsFor” rules is expressed by means of “union_all”. \nThis rule is expressed in the language of RTEC as follows:\n    ```prolog\n    holdsFor(underWay(Vessel)=true, I) :-\n        holdsFor(movingSpeed(Vessel)=below, I1),\n        holdsFor(movingSpeed(Vessel)=normal, I2),\n        holdsFor(movingSpeed(Vessel)=above, I3),\n        union_all([I1,I2,I3], I).\n    ```"
    },
    {
      "user": "Given a composite maritime activity description, provide the rules in the language of RTEC.\nComposite Maritime Activity Description: “rendezVous”: This activity lasts as long as two vessels \nare close to each other, their speed is low and they are far from the coastline. \nFurthermore, neither of the two vessels should be a tug boat or a pilot vessel. \nWe are interested in vessel meetings whose duration exceeds the expected minimum time required \nfor a suspicious action, like an illegal cargo transfer.",
      "assistant": "The activity “rendezVous” is expressed as a statically determined fluent. \nWe use a “holdsFor” rule to describe that the “rendezVous” activity lasts as long as two vessels, \nneither of which is a tug boat or a pilot vessel, are both sailing at a low speed or are stopped \nfar from all ports, while neither of them is close to a port or a coastline. \nThe output is a Boolean fluent named “rendezVous” with two arguments, i.e. “Vessel1” and “Vessel2”. \nTo express that the two vessels must be close to each other, we use a Boolean fluent named “proximity” with two arguments, i.e. “Vessel1” and “Vessel2”. \nTo express that neither of the vessels is a tug boat or a pilot vessel, we use a background knowledge predicate named “oneIsTug” with two arguments, \ni.e. “Vessel1” and “Vessel2”, and a background knowledge predicate named “oneIsPilot” with two arguments, i.e. “Vessel1” and “Vessel2”, \nand require that these predicates do not hold using “not”. To express that “Vessel1” has a low speed \nor it is stopped far from all ports, we use the predicate “union_all”. \nSimilarly, we employ “union_all” to express that “Vessel2” has a low speed or it is stopped far from all ports. \nNext, we use the predicate “intersect_all” to express the conjunction of these two events, \ni.e., that both vessels need to have a low speed or be stopped far from all ports. \nSubsequently, we need to express that neither of the two vessels is near a port or a coastline at this time. \nTo do this, we employ the predicate “relative_complement_all”, in order to exclude the situations \nwhere “Vessel1” is near a port, “Vessel1” is near a coastline, “Vessel2” is near a port or “Vessel2” is near a coastline. \nFinally, we need to express that the duration of the activity is greater than the minimum expected duration of a rendez-vous among vessels. \nTo do this, we use the background knowledge predicate “thresholds” to retrieve this minimum duration from background knowledge and store it in the variable “RendezvousTime”. \nThen, we use the background knowledge predicate “intDurGreater” in order to filter the intervals that have been computed so far, maintaining only the ones whose duration exceeds “RendezvousTime”. \nThis rule in RTEC language is:\n```prolog\n    holdsFor(rendezVous(Vessel1, Vessel2)=true, I) :-\n        holdsFor(proximity(Vessel1, Vessel2)=true, Ip),\n        not oneIsTug(Vessel1, Vessel2),\n        not oneIsPilot(Vessel1, Vessel2),\n        holdsFor(lowSpeed(Vessel1)=true, Il1),\n        holdsFor(lowSpeed(Vessel2)=true, Il2),\n        holdsFor(stopped(Vessel1)=farFromPorts, Is1),\n        holdsFor(stopped(Vessel2)=farFromPorts, Is2),\n        union_all([Il1, Is1], I1b),\n        union_all([Il2, Is2], I2b),\n        intersect_all([I1b, I2b, Ip], If), If\\=[],\n        holdsFor(withinArea(Vessel1, nearPorts)=true, Iw1),\n        holdsFor(withinArea(Vessel2, nearPorts)=true, Iw2),\n        holdsFor(withinArea(Vessel1, nearCoast)=true, Iw3),\n        holdsFor(withinArea(Vessel2, nearCoast)=true, Iw4),\n        relative_complement_all(If,[Iw1, Iw2, Iw3, Iw4], Ii),\n        thresholds(rendezvousTime, RendezvousTime),\n        intDurGreater(Ii, RendezvousTime, I).\n    ```"
    },
    {
      "user": "Given a composite activity description, provide the rules in the language of RTEC. You may use the built-in events of RTEC, the MSA events, the MSA input fluents, and the MSA background knowledge predicates. You may also use any of the MSA output fluents that you have already learned.\nComposite Maritime Activity Description - “gap”: A communication gap starts when we stop receiving messages from a vessel. We would like to distinguish the cases where a communication gap starts (i) near some port and (ii) far from all ports. A communication gap ends when we resume receiving messages from a vessel.",
      "assistant": "initiatedAt(gap(Vessel)=nearPorts, T) :-\n                                happensAt(gap_start(Vessel), T),\n                                holdsAt(withinArea(Vessel, nearPorts)=true, T).\n\n                        initiatedAt(gap(Vessel)=farFromPorts, T) :-\n                                happensAt(gap_start(Vessel), T),\n                                \\+holdsAt(withinArea(Vessel, nearPorts)=true, T).\n\n                        terminatedAt(gap(Vessel)=_PortStatus, T) :-\n                                happensAt(gap_end(Vessel), T)."
    }
  ],
  "extra": {}
}